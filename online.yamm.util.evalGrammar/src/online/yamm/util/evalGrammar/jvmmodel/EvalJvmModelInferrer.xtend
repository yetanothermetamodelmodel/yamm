/*
 * generated by Xtext 2.14.0
 */
package online.yamm.util.evalGrammar.jvmmodel

import com.google.inject.Inject
import online.yamm.util.evalGrammar.eval.Model
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import java.util.Map.Entry
import java.util.List
import org.eclipse.xtext.common.types.TypesFactory
import org.eclipse.xtext.common.types.access.IJvmTypeProvider
import org.eclipse.emf.ecore.EObject

/**
 * <p>Infers a JVM model from the source model.</p> 
 *
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class EvalJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		acceptor.accept(element.toClass("_Ouput_Eval")) [

			members += element.toField("atrA", typeRef(String))

			members += element.toMethod("containerMethod", typeRef(double)) [
				var JvmFormalParameter param = element.toParameter("output", getParameterTyp(element))
				parameters += param
				static = false;
				var typeRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
				typeRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Exception");
				exceptions += typeRef
				body = element.expression
			]
			
			members += element.toMethod("max", typeRef(double)) [
				var JvmFormalParameter param = element.toParameter("output", getParameterTyp(element))
				parameters += param
				static = false;
				var typeRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
				typeRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Exception");
				exceptions += typeRef
				body = '''
					double max = output.get(0).getValue();
					for (TimeToValue tv : output){
						if(max < ((double) tv.getValue())){
							max = (double) tv.getValue();
						}
					}
					return max;
				'''
			]
		
			members += element.toMethod("min", typeRef(double)) [
				var JvmFormalParameter param = element.toParameter("output", getParameterTyp(element))
				parameters += param
				static = false;
				var typeRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
				typeRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Exception");
				exceptions += typeRef
				body = '''
					double min = output.get(0).getValue();
					for (TimeToValue tv : output){
						if(min > ((double) tv.getValue())){
							min = (double) tv.getValue();
						}
					}
					return min;
				'''
			]
			
			members += element.toMethod("average", typeRef(double)) [
				var JvmFormalParameter param = element.toParameter("output", getParameterTyp(element))
				parameters += param
				static = false;
				var typeRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
				typeRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Exception");
				exceptions += typeRef
				body = '''
					double avarage = 0;
					for (TimeToValue tv : output){
						avarage += (double) tv.getValue();
					}
					avarage = avarage / output.size();
					return avarage;
				'''
			] 
		]
		
		
	}
	@Inject IJvmTypeProvider.Factory jdtTypesProviderFactory
	
	def getParameterTyp(EObject element){
		var typeRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
		var entryRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
		var integerRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
		var doubleRef = TypesFactory.eINSTANCE.createJvmParameterizedTypeReference();
		
		var listTyp = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.util.List");
		entryRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("online.yamm.gui.TimeToValue");
		integerRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Integer");
		doubleRef.type = jdtTypesProviderFactory.findOrCreateTypeProvider(element.eResource().getResourceSet()).findTypeByName("java.lang.Double");
		
		
		typeRef.type = listTyp
		typeRef.arguments.add(entryRef)
		entryRef.arguments.add(integerRef)
		entryRef.arguments.add(doubleRef)
		return typeRef
	}
}
